#include "ass.h"
#include "stb_ds.h"

#include <stdio.h>
#include <assert.h>
//#include <sys/param.h>
#include <stdio.h>
#include <stdalign.h>
#include <math.h>
#include "util.h"
#include "font.h"
#include "fontmetrics.h"
#include "tagtext.h"
#include "opts.h"
#include "log.h"

#define ASS_RGBA(r, g, b, a) (((a) << 24) | ((b) << 16) | ((g) << 8) | (r))
#define ARIB_TO_ASS_COLOR(aribcolor) (ASS_RGBA((uint8_t)ARIBCC_COLOR_R(aribcolor), (uint8_t)ARIBCC_COLOR_G(aribcolor), \
                    (uint8_t)ARIBCC_COLOR_B(aribcolor), 0xff - (uint8_t)ARIBCC_COLOR_A(aribcolor)))


struct ass_style {
    const char *name;
    const char *fontname;
    float fs, border, shadow;
    uint32_t primary_color, border_color, shadow_color;
    int align;
    float scale_x, scale_y, spacing_x;
    bool bold, italic, underline;
};

struct ass_ctx {
    struct fm_ctx fm;
    struct ass_style default_style;
    struct font font;
};

static void ms_to_str(int64_t ms_time, char out[32])
{
    int64_t h, m, s, ms;
    h = ms_time / H_IN_MS;
    ms_time %= H_IN_MS;

    m = ms_time / M_IN_MS;
    ms_time %= M_IN_MS;

    s = ms_time / S_IN_MS;
    ms = ms_time % S_IN_MS;

    snprintf(out, 32, "%"PRId64":%02"PRId64":%02"PRId64".%02"PRId64, h, m, s, ms /  10);
}

static void write_header(FILE *f, int width, int height)
{
    fprintf(f, 
            "[Script Info]\n"
            "; Script generated by arib2ass-cstyle\n"
            "ScriptType: v4.00+\n"
            "Collisions: Normal\n"
            "ScaledBorderAndShadow: Yes\n"
            "PlayResX: %d\n"
            "PlayResY: %d\n"
            "LayoutResX: %d\n"
            "LayoutResY: %d\n"
            "\n",
            width, height, width, height);
}

static void write_styles(FILE *f, const struct ass_style *s)
{
    sftf_init();

    fprintf(f,
            "[V4+ Styles]\n"
            "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
            "Style: %s,%s,%s,&H%08X,&H00000000,&H%08X,&H%08X,%d,%d,%d,0,%s,%s,%s,0,1,%s,%s,%d,0,0,0,1\n"
            "\n", s->name, s->fontname, sftf(s->fs), s->primary_color, s->border_color, s->shadow_color, s->bold, s->italic, s->underline,
            sftf(s->scale_x * 100), sftf(s->scale_y * 100), sftf(s->spacing_x), sftf(s->border), sftf(s->shadow), s->align);
}

static void ass_style_update_from_tt_events(const struct tagtext_event events[TT_STYLE_COUNT_], struct ass_style *out_style)
{
    for (int i = 0; i < TT_STYLE_COUNT_; i++) {
        const struct tagtext_event *ev = &events[i];
        assert(ev->type == TT_EVENT_TYPE_STYLE);

#define smap(style, selem, val) \
        case style: \
            out_style->selem = ev->val; \
            break;

#define smapcolor(style, selem, val) \
        case style: \
            out_style->selem = ARIB_TO_ASS_COLOR(ev->val); \
        break;

        switch (ev->style) {
            smapcolor(TT_STYLE_TEXT_COLOR, primary_color, style_value_u32)
            smapcolor(TT_STYLE_BACK_COLOR, shadow_color, style_value_u32)
            smapcolor(TT_STYLE_STROKE_COLOR, border_color, style_value_u32)
            smap(TT_STYLE_SCALE_X, scale_x, style_value_float)
            smap(TT_STYLE_SCALE_Y, scale_y, style_value_float)
            smap(TT_STYLE_SPACING_X, spacing_x, style_value_float)
            smap(TT_STYLE_CHAR_HEIGHT, fs, style_value_u32)
            smap(TT_STYLE_BOLD, bold, style_value_bool)
            smap(TT_STYLE_ITALIC, italic, style_value_bool)
            smap(TT_STYLE_UNDERLINE, underline, style_value_bool)

            case TT_STYLE_SPACING_Y:
            case TT_STYLE_CHAR_WIDTH:
            case TT_STYLE_STROKE:
                /* ignore */
                break;
            default:
                assert(false && "Unknown style");
#undef smapcolor
#undef smap
        }
    }
}

static void ass_default_style(struct ass_style *out_style)
{
    *out_style = (struct ass_style){
        .name = "Default",
        .fontname = NULL,
        .fs = 36,
        .align = 4,
        .bold = true,
        .scale_x = 1,
        .scale_y = 1,
        .border = 2,
        .shadow = 2,
        .border_color = ASS_RGBA(0, 0, 0, 0),
        .shadow_color = ASS_RGBA(0, 0, 0, 0x7f),
        .primary_color = ASS_RGBA(0xff, 0xff, 0xff, 0),
    };
}

#define brace_switch(to_state, curri, size, buffer) { \
    if (*in_brace != to_state) { \
        buffer[curri++] = "}{"[to_state]; \
        size--; \
        assert(curri < size); \
        *in_brace = to_state; \
    } \
}

static int render_tagtext_event_style(const struct tagtext_event *ev, const struct tagtext_event *all_events, ssize_t size, char *out_text, bool *in_brace)
{
    assert(size > 0);
    assert(ev->type == TT_EVENT_TYPE_STYLE);

    int w = 0;
    bool b_switched = false;

    if (*in_brace == false) {
        b_switched = true;
        brace_switch(true, w, size, out_text);
        out_text++;
    }

    sftf_init();
    switch (ev->style) {
        /* Colors are BGR */
        case TT_STYLE_TEXT_COLOR:
            w += snprintf(out_text, size, "\\c&H%02X%02X%02X&\\1a&H%02X",
                    (uint8_t)ARIBCC_COLOR_B(ev->style_value_u32), (uint8_t)ARIBCC_COLOR_G(ev->style_value_u32),
                    (uint8_t)ARIBCC_COLOR_R(ev->style_value_u32), 0xff - (uint8_t)ARIBCC_COLOR_A(ev->style_value_u32));
            break;
        case TT_STYLE_BACK_COLOR:
            w += snprintf(out_text, size, "\\-STYLE_BACK_COLOR");
            break;
        case TT_STYLE_STROKE_COLOR:
            w += snprintf(out_text, size, "\\3c&H%02X%02X%02X&\\3a&H%02X",
                    (uint8_t)ARIBCC_COLOR_B(ev->style_value_u32), (uint8_t)ARIBCC_COLOR_G(ev->style_value_u32),
                    (uint8_t)ARIBCC_COLOR_R(ev->style_value_u32), 0xff - (uint8_t)ARIBCC_COLOR_A(ev->style_value_u32));
            break;
        case TT_STYLE_SCALE_X:
            w += snprintf(out_text, size, "\\fscx%s", sftf(ev->style_value_float * 100.0f));
            break;
        case TT_STYLE_SCALE_Y:
            w += snprintf(out_text, size, "\\fscy%s", sftf(ev->style_value_float * 100.0f));
            break;
        case TT_STYLE_SPACING_X: {
            /* NOTE: \fsp is scaled by \fscx */
            w += snprintf(out_text, size, "\\fsp%s", sftf(ev->style_value_float));
        }
            break;
        case TT_STYLE_SPACING_Y:
            w += snprintf(out_text, size, "\\-STYLE_SPACING_Y=%d", (int)ev->style_value_u32);
            break;
        case TT_STYLE_CHAR_HEIGHT:
            w += snprintf(out_text, size, "\\fs%u", ev->style_value_u32);
            break;
        /* Bold is ignored, always set */
        case TT_STYLE_BOLD:
            return snprintf(out_text, size, "\\b%d", ev->style_value_bool);
            break;
        case TT_STYLE_ITALIC:
            w += snprintf(out_text, size, "\\i%d", ev->style_value_bool);
            break;
        case TT_STYLE_UNDERLINE:
            w += snprintf(out_text, size, "\\u%d", ev->style_value_bool);
            break;
        case TT_STYLE_STROKE:
            w += snprintf(out_text, size, "\\-stroke=%d", ev->style_value_bool);
            break;
        case TT_STYLE_RESET:
            w += snprintf(out_text, size, "\\r");
            break;
#if 0
        case TT_STYLE_POS_XY:
            //return snprintf(out_text, size, "\\pos(%d,%d)", ev->style_value_u32 >> 16, ev->style_value_u32 & 0xffff);
            break;
#endif
        default:
            break;
    }

    if (w == 1 && b_switched) {
        /* No tag was written, but the opening brace was so revert that here */
        out_text--;
        *out_text = '\0';
        *in_brace = false;
        w = 0;
    }

    return w;
}

static int render_tagtext_event_char(const struct tagtext_event *ev, ssize_t size, char *out_text, bool *in_brace)
{
    assert(size > 0);
    assert(ev->type == TT_EVENT_TYPE_CHAR);

    int w = 0;

    brace_switch(false, w, size, out_text);

    if (ev->ref_so_chr->ref->codepoint == '\n') {
        w += snprintf(&out_text[w], size - w, "\\N");
    } else {
        w += snprintf(&out_text[w], size - w, "%s", ev->ref_so_chr->ref->u8str);
    }
    return w;
}

#undef brace_switch

struct ass_lines {
    char *storage;
    size_t storage_size;
    size_t storage_idx;

    size_t lines_idx, lines_size;
    struct ass_line {
        int layer;
        char *text_ptr;
    } lines[128];
};

static void render_tagtext_events(const struct tagtext_event *events, struct ass_lines *alines, bool in_brace)
{

    for (const struct tagtext_event *ev = events; ev < &events[arrlen(events)]; ev++) {
        int w = 0;
        if (ev->type == TT_EVENT_TYPE_STYLE) {
            w = render_tagtext_event_style(ev, events, alines->storage_size - alines->storage_idx, &alines->storage[alines->storage_idx], &in_brace);
        } else {
            w = render_tagtext_event_char(ev, alines->storage_size - alines->storage_idx, &alines->storage[alines->storage_idx], &in_brace);
        }
        alines->storage_idx += w;
        assert(alines->storage_idx < alines->storage_size);
    }
}

static void render_debug_boxes(struct ass_ctx *actx, struct tagtext_caption *tt_caption, struct ass_lines *alines)
{
    /* region and char bounding box */
    for (uint32_t ri = 0; ri < tt_caption->ref_subobj->caption_ref.region_count; ri++) {
        const aribcc_caption_region_t *ref_region = &tt_caption->ref_subobj->caption_ref.regions[ri];
        struct ass_line *cur_line = &alines->lines[alines->lines_idx++];
        assert(alines->lines_idx < alines->lines_size);

        cur_line->layer = 0;
        cur_line->text_ptr = &alines->storage[alines->storage_idx];
        alines->storage_idx += snprintf(cur_line->text_ptr, alines->storage_size - alines->storage_idx,
                "{\\c&H000000&\\alpha&HA0&\\an7\\bord0\\shad0\\pos(%d,%d)\\p1}m %d %d l %d %d %d %d %d %d",
                ref_region->x, ref_region->y, 0, 0, ref_region->width, 0, ref_region->width, ref_region->height, 0, ref_region->height);
        alines->storage_idx++;
        assert(alines->storage_idx < alines->storage_size);

        for (intptr_t ref_chr_i = 0; ref_chr_i < ref_region->char_count; ref_chr_i++) {
            const aribcc_caption_char_t *ref_chr = &ref_region->chars[ref_chr_i];
            int cw = aribcc_caption_char_get_section_width((void*)ref_chr);
            int ch = aribcc_caption_char_get_section_height((void*)ref_chr);

            struct ass_line *cur_line = &alines->lines[alines->lines_idx++];
            assert(alines->lines_idx < alines->lines_size);

            cur_line->layer = 1;
            cur_line->text_ptr = &alines->storage[alines->storage_idx];

            alines->storage_idx += snprintf(cur_line->text_ptr, alines->storage_size - alines->storage_idx,
                    "{\\c&H000000&\\1a&HFF&\\3c&H00000000&\\3a&H00&\\an7\\bord1\\shad0\\pos(%d,%d)\\p1}m %d %d l %d %d %d %d %d %d",
                    ref_chr->x, ref_chr->y, 0, 0, cw, 0, cw, ch, 0, ch);
            alines->storage_idx++;
            assert(alines->storage_idx < alines->storage_size);
        }
    }


    struct chars_for_furi_result rubys[MAX_FURI_REGIONS];
    int rubylen = util_find_chars_for_furi(tt_caption->ref_subobj, rubys);
    for (int i = 0; i < rubylen; i++) {
        struct ass_line *cur_line = &alines->lines[alines->lines_idx++];
        assert(alines->lines_idx < alines->lines_size);

        assert(rubys[i].chars_region->char_count > rubys[i].chars_span_from);
        int x1 = rubys[i].chars_region->chars[rubys[i].chars_span_from].x;
        int x2 = rubys[i].chars_region->chars[rubys[i].chars_span_to].x + 
            rubys[i].chars_region->chars[rubys[i].chars_span_to].char_width;
        int y1 = rubys[i].chars_region->y;
        int y2 = y1 + rubys[i].chars_region->height;


        cur_line->layer = 2;
        cur_line->text_ptr = &alines->storage[alines->storage_idx];

        alines->storage_idx += snprintf(cur_line->text_ptr, alines->storage_size - alines->storage_idx,
                "{\\c&H0000FF&\\alpha&HA0&\\an7\\bord0\\shad0\\pos(%d,%d)\\p1}m %d %d l %d %d %d %d %d %d",
                x1, y1, 0, 0, x2 - x1, 0, x2 - x1, y2 - y1, 0, y2 - y1);
        alines->storage_idx++;
        assert(alines->storage_idx < alines->storage_size);

#if 0
        pprintf(PSTR("Matched furi: "));
        for (int ci = rubys[i].chars_span_from; ci <= rubys[i].chars_span_to; ci++) {
            pprintf(PSTR("%s"), u8PC(rubys[i].chars_region->chars[ci].u8str));
        }
        pprintf(PSTR(" ("));
        for (int ci = 0; ci < rubys[i].furi_region->char_count; ci++) {
            pprintf(PSTR("%s"), u8PC(rubys[i].furi_region->chars[ci].u8str));
        }
        pprintf(PSTR(")\n"));
#endif
    }

}

static void render_caption(struct ass_ctx *actx, struct tagtext_caption *tt_caption, struct ass_lines *alines)
{
    assert(tt_caption);

    if (opt_ass_only_furi == true) {
        bool has_ruby = false;
        for (uint32_t ri = 0; ri < tt_caption->ref_subobj->caption_ref.region_count; ri++) {
            if (tt_caption->ref_subobj->caption_ref.regions[ri].is_ruby == true) {
                has_ruby = true;
                break;
            }
        }

        if (has_ruby == false)
            return;
    }

    for (intptr_t tti = 0; tti < arrlen(tt_caption->tagtexts); tti++) {
        struct tagtext *tt = &tt_caption->tagtexts[tti];
        const struct subobj_caption_region *so_region = &tt_caption->ref_subobj->so_caption.so_regions[tti];


        struct ass_line *cur_line = &alines->lines[alines->lines_idx++];
        assert(alines->lines_idx < alines->lines_size);
        cur_line->layer = (opt_ass_debug_boxes) ? 3 : 0;
        cur_line->text_ptr = &alines->storage[alines->storage_idx];
        alines->storage_idx += snprintf(cur_line->text_ptr, alines->storage_size - alines->storage_idx,
                "{\\pos(%d,%d)", so_region->x, so_region->y + (so_region->height / 2));
        assert(alines->storage_idx < alines->storage_size);

        render_tagtext_events(tt->events, alines, true);

        alines->storage_idx++;
    }


    if (opt_ass_debug_boxes) {
        render_debug_boxes(actx, tt_caption, alines);
    }
}

static void calculate_char_spacing(struct ass_ctx *actx, struct subobj_caption_char *so_chr)
{
    /* How scaling and fsp works in libass:
     * \fsp is scaled with the \fscx.
     * To calculate the real width of a character, use
     * real_width = (char_width + fsp) * fscx
     * therefore, use this to calculate the required \fsp for an expected real_width
     * fsp = (expected_width / fscx) - char_width
     */
    struct text_extents char_act_size = {0};
    float char_exp_width, char_act_width;

    char_exp_width = (so_chr->char_width + so_chr->char_horizontal_spacing) * so_chr->char_horizontal_scale;
    fm_get_metrics_fs_cp(&actx->fm, so_chr->ref->codepoint, so_chr->char_height, &char_act_size);
    char_act_width = char_act_size.width;

    so_chr->char_horizontal_spacing = (char_exp_width / so_chr->char_horizontal_scale) - char_act_width;
}

static void merge_captions(struct subobj_caption_region *base, struct subobj_caption_region *add)
{
    assert(base->x == add->x);
    assert(base->y + base->height == add->y);
    char u8str[8] = { '\n' };
    struct subobj_caption_char ref_so_chr = base->so_chars[arrlen(base->so_chars) - 1]; // can't use a ptr because it will change.
    aribcc_caption_char_t *newchar = malloc(sizeof(*newchar)), *newchar_fs = malloc(sizeof(*newchar_fs));
    assert(newchar);
    assert(newchar_fs);
    *newchar    = *ref_so_chr.ref;
    *newchar_fs = *ref_so_chr.ref;
    ref_so_chr.owned_chr = true;

    newchar->codepoint = newchar_fs->codepoint = '\n';
    memcpy(newchar->u8str, u8str, sizeof(u8str));
    memcpy(newchar_fs->u8str, u8str, sizeof(u8str));

    base->height += add->height;
    arrsetcap(base->so_chars, arrlen(base->so_chars) + 2 + arrlen(add->so_chars));

    // add a newline character with the same style as the previous char
    ref_so_chr.chr = newchar;
    arrput(base->so_chars, ref_so_chr);

    assert(newchar_fs->char_vertical_scale == 1);
    // add a newline character with changed character height
    ref_so_chr.chr = newchar_fs;
    ref_so_chr.char_height = (ref_so_chr.char_height / 2) + ref_so_chr.chr->char_vertical_spacing;
    arrput(base->so_chars, ref_so_chr);

    for (struct subobj_caption_char *so_chr = add->so_chars; so_chr < arrendptr(add->so_chars); so_chr++) {
        arrput(base->so_chars, *so_chr);
    }
}

/* Retun the index of the first non-ruby region (the count of ruby regions) */
static intptr_t reorder_ruby_regions(struct subobj_caption_region stb_array *regions)
{
    size_t first_ruby_insert_idx = 0;

    for (intptr_t ri = 0; ri < arrlen(regions); ri++) {
        if (regions[ri].ref->is_ruby) {
            if (ri != first_ruby_insert_idx) {
                arrmovelem(regions, ri, first_ruby_insert_idx, sizeof(*regions));
            }
            first_ruby_insert_idx++;
        }
    }

    return first_ruby_insert_idx;
}

static void coalesce_sections_bef(struct ass_ctx *actx, struct subobj_caption_region *stb_array *regions)
{
    if (arrlen(*regions) <= 1)
        return;

    struct subobj_caption_region stb_array *new_so_regions = NULL;
    bool current_set = false;
    struct subobj_caption_region current;
    intptr_t first_non_ruby_idx;

    /* Put ruby sections at the start */
    first_non_ruby_idx = reorder_ruby_regions(*regions);
    if (first_non_ruby_idx >= arrlen(*regions)) {
        /* Only has ruby *regions (very unlikely) */
        return;
    }

    if ((arrlen(*regions) - first_non_ruby_idx) <= 1) {
        /* Only 1 non-ruby region */
        return;
    }

    /* Copy the ruby sections first if any */
    struct subobj_caption_region *rubyreg = arraddnptr(new_so_regions, first_non_ruby_idx);
    for (intptr_t ruby_i = 0; ruby_i < first_non_ruby_idx; ruby_i++) {
        subobj_caption_region_copy(&rubyreg[ruby_i], &(*regions)[ruby_i]);
    }

    for (intptr_t ri = first_non_ruby_idx; ri < arrlen(*regions); ri++) {
        struct subobj_caption_region *region = &(*regions)[ri];
        if (current_set == false) {
            subobj_caption_region_copy(&current, region);
            current_set = true;
            continue;
        }

        if (current.x == region->x && current.y + current.height == region->y) {
            merge_captions(&current, region);
        } else {
            arrput(new_so_regions, current);
            subobj_caption_region_copy(&current, region);
            current_set = true;
        }
    }

    if (current_set == true)
        arrput(new_so_regions, current);

    if (new_so_regions) {
        subobj_caption_regions_free(*regions);
        *regions = new_so_regions;
    }
}

static void recalc_center_spacing(struct ass_ctx *actx, struct subobj_caption_region *so_region)
{
    if (arrlen(so_region->so_chars) <= 0)
        return;

    so_region->so_chars[0].char_horizontal_spacing /= 2;
    so_region->x += (so_region->so_chars[0].char_horizontal_spacing * so_region->so_chars[0].char_horizontal_scale);

    for (intptr_t ci = 1; ci < arrlen(so_region->so_chars); ci++) {
        struct subobj_caption_char *cbef = &so_region->so_chars[ci - 1];
        struct subobj_caption_char *cnow = &so_region->so_chars[ci    ];

        cnow->char_horizontal_spacing /= 2;
        cbef->char_horizontal_spacing += ((cnow->char_horizontal_spacing * cnow->char_horizontal_scale) / cbef->char_horizontal_scale);
    }
}

static bool shift_ruby(struct ass_ctx *actx, struct subobj_caption *so_caption)
{
    for (intptr_t ri = 0; ri < arrlen(so_caption->so_regions); ri++) {
        struct subobj_caption_region *ruby = &so_caption->so_regions[ri];

        if (ruby->ref->is_ruby == false)
            continue;

        const struct subobj_caption_region *main_region = util_main_so_region_for_ruby(so_caption, ruby);
        if (main_region == NULL) {
            return false;
        }

        float virt_x = 0, real_x = 0;
        for (struct subobj_caption_char *chr = main_region->so_chars; chr < arrendptr(main_region->so_chars); chr++) {
            struct text_extents ex;
            if (chr->ref->x >= ruby->ref->x)
                break;
            fm_get_metrics_fs_cp(&actx->fm, chr->ref->codepoint, chr->char_height, &ex);
            virt_x += aribcc_caption_char_get_section_width((void*)chr->ref);
            real_x += (ex.width + chr->char_horizontal_spacing) * chr->char_horizontal_scale;
        }

        ruby->x -= (virt_x - real_x);
    }
    return true;
}

static void process_chars(struct ass_ctx *actx, struct subobj *subobjs)
{
    int newfs = -1, oldfs = -1;

    for (struct subobj *s = subobjs; s < arrendptr(subobjs); s++) {
        if (s->so_caption.so_regions == NULL)
            continue;
        for (struct subobj_caption_region *so_region = s->so_caption.so_regions; so_region < arrendptr(s->so_caption.so_regions); so_region++) {
            for (struct subobj_caption_char *so_chr = so_region->so_chars; so_chr < arrendptr(so_region->so_chars); so_chr++) {

                if (opt_ass_fs_adjust) {
                    if (newfs == -1 || oldfs != so_chr->char_height) {
                        oldfs = so_chr->char_height;
                        newfs = fm_adjust_fs(&actx->fm, so_chr->char_height);
                        if (newfs != oldfs) {
                            log_info("Adjusted fontsize from %d to %d\n", oldfs, newfs);
                        }
                    }

                    so_chr->char_height = newfs;
                }

                if (opt_ass_constant_spacing == -1)
                    calculate_char_spacing(actx, so_chr);
                else
                    so_chr->char_horizontal_spacing = opt_ass_constant_spacing;

                if (opt_ass_force_bold)
                    so_chr->style |= ARIBCC_CHARSTYLE_BOLD;
                if (opt_ass_force_border) {
                    so_chr->style |= ARIBCC_CHARSTYLE_STROKE;
                    so_chr->stroke_color = ARIBCC_MAKE_RGBA(0u, 0u, 0u, 0xffu);
                }
            }

            if (opt_ass_center_spacing && opt_ass_constant_spacing == -1) {
                recalc_center_spacing(actx, so_region);
            }
        }

        if (opt_ass_shift_ruby && opt_ass_constant_spacing != -1) {
            bool ok = shift_ruby(actx, &s->so_caption);
            if (ok == false) {
                pchar tm[32];
                util_ms_to_htime(s->start_ms, tm);
                log_warning("Failed to shift ruby at: %s\n", tm);
            }
        }

        if (opt_ass_merge_regions) {
            coalesce_sections_bef(actx, &s->so_caption.so_regions);
        }
    }
}

enum error ass_write(const struct subobj_ctx *sctx, const pchar *filepath)
{
    struct ass_ctx actx = { 0 };
    struct tagtext_caption *tt_captions = NULL;
    enum error err = NOERR;
    struct tagtext_event default_styles[TT_STYLE_COUNT_];
    FILE *f = NULL;

    err = font_create(opt_ass_font_path, opt_ass_font_face, &actx.font);
    if (err != NOERR)
        goto end;

    fm_create(&actx.font, &actx.fm);
    ass_default_style(&actx.default_style);
    actx.default_style.fontname = actx.font.fontname;
    /* rest of style is 0 before optimization */

    process_chars(&actx, sctx->subobjs);

    err = tagtext_parse_captions(sctx->subobjs, &tt_captions, opt_ass_optimize ? default_styles : NULL);
    if (err != NOERR) {
        goto end;
    }
    if (opt_ass_optimize) {
        ass_style_update_from_tt_events(default_styles, &actx.default_style);
    }

    f = pfopen(filepath, PSTR("wb"));
    if (f == NULL) {
        err = -errno;
        goto end;
    }

    if (arrlen(sctx->subobjs) > 0) {
        const struct subobj *s = &sctx->subobjs[0];
        write_header(f, s[0].caption_ref.plane_width, s[0].caption_ref.plane_height);

        write_styles(f, &actx.default_style);
    }

    fputs(
        "[Events]\n"
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n",
        f);

    for (intptr_t i = 0; i < arrlen(tt_captions); i++) {
        char start_str[32], end_str[32], text_buffer[16*1024];
        struct ass_lines alines = {
            .storage = text_buffer,
            .storage_size = sizeof(text_buffer),
            .lines_size = ARRAY_COUNT(alines.lines),
        };
        struct tagtext_caption *ttc = &tt_captions[i];

        ms_to_str(ttc->ref_subobj->start_ms, start_str);
        ms_to_str(ttc->ref_subobj->end_ms, end_str);

        render_caption(&actx, ttc, &alines);

        for (struct ass_line *al = &alines.lines[0]; al < &alines.lines[alines.lines_idx]; al++) {
            fprintf(f, "Dialogue: %d,%s,%s,Default,,0000,0000,0000,,%s\n", al->layer, start_str, end_str, al->text_ptr);
        }
    }

end:
    if (f)
		fclose(f);
    fm_destroy(&actx.fm);
    font_destroy(&actx.font);
    if (tt_captions)
		tagtext_captions_free(tt_captions);
    return err;
}
